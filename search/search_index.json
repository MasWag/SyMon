{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SyMon","text":"<p>SyMon is a tool for symbolic monitoring, where the specification may be parametric both in time and data (i.e., the specification may contain unknown constants). Currently, SyMon supports string and numbers as data.</p> <p>SyMon is implemented in C++. SyMon uses Parma Polyhedra Library for polyhedra operations. SyMon is distributed under the GNU General Public License Version 3.0.</p> <p>SyMon is mainly developed by Masaki Waga.</p>"},{"location":"#reference","title":"Reference","text":"<ul> <li>Masaki Waga, \u00c9tienne Andr\u00e9, and Ichiro Hasuo, Symbolic Monitoring against Specifications Parametric in Time and Data, In Proc. CAV 2019. LNCS 11561, pp. 520-539 arXiv version</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>The following is a list of examples. </p> Name Description Specification Document Relay Relay Detection in an SMTP server relay.symon Document Frequent Frequent Message Detection in an SMTP server frequent.symon Document Withdraw Detect too much withdrawals in a short period. This example is inspired by an example in https://easychair.org/publications/paper/62MC withdraw.symon Periodic Detect periodic withdrawals. periodic.symon FluxCD Detect delay in polling. final.symon Preprint"},{"location":"getting_started/","title":"Getting Started","text":"<p>Let's look at some examples of SyMon usage. See also this document for the details of the specification language supported by SyMon. In this document, we assume that SyMon can be executed by <code>symon</code>. Replace <code>symon</code> with the actual executable path if your environment differs. Installation instructions are available here.</p> <p>Consider the following as the monitored log. It is also in <code>example/exim4/frequent/example.log</code>.</p> <pre><code>arrival alice@example.com   0.0\narrival bob@example.org 0.3\narrival alice@example.com   0.5\narrival carol@example.net   0.7\narrival alice@example.com   0.8\narrival alice@example.com   1.0\narrival bob@example.org 1.2\narrival alice@example.com   1.5\narrival alice@example.com   1.7\narrival alice@example.com   1.9\narrival carol@example.net   2.0\narrival alice@example.com   2.2\narrival alice@example.com   2.4\narrival bob@example.org 2.5\narrival alice@example.com   2.7\narrival carol@example.net   2.9\narrival alice@example.com   3.1\narrival bob@example.org 3.25\narrival alice@example.com   3.3\narrival bob@example.org 3.4\n</code></pre>"},{"location":"getting_started/#signature-declaration","title":"Signature declaration","text":"<p>In SyMon, we first must declare the signature, i.e., the kind of events with the associated data. In the above log, we have only one kind of log (<code>arrival</code>) associated with a string-valued email address and a timestamp. For such events, the signature declaration is as follows.</p> <pre><code>signature arrival {\n    sender: string;\n}\n</code></pre>"},{"location":"getting_started/#your-first-example","title":"Your first example","text":"<p>Let's detect the first occurrence of an email from <code>carol@example.net</code>. This can be done by 1) skipping the arrival of a message not from <code>carol@example.net</code> and 2) ending with the arrival of a message from <code>carol@example.net</code>. The following expression encodes such a specification.</p> <pre><code>zero_or_more {\n    arrival( sender | sender != \"carol@example.net\" )\n};\narrival( sender | sender == \"carol@example.net\" )\n</code></pre> <p><code>zero_or_more</code> means possible repetition of the expression inside. This is the same notion of Kleene star as in regular expressions. In this example, SyMon first finds a repetition of message arrivals that are not from <code>carol@example.net</code>. Then, we detect the message arrival from <code>carol@example</code>. Alternatively, one can also write it using <code>*</code> operation as follows.</p> <pre><code>arrival( sender | sender != \"carol@example.net\" )*;\narrival( sender | sender == \"carol@example.net\" )\n</code></pre> <p>In SyMon's specification language, the signature declaration must be put before the expression. The following is a complete specification.</p> <pre><code>signature arrival {\n    sender: string;\n}\n\nzero_or_more {\n    arrival(sender | sender != \"carol@example.net\" )*\n};\narrival(sender | sender == \"carol@example.net\" )\n</code></pre> <p>An example of the usage and the result is as follows.</p> <pre><code>symon -nf ./first-carol.symon &lt; example.log\n</code></pre> <pre><code>@0.700000.  (time-point 3)  true\n</code></pre> <p>The result shows that SyMon detected the given specification at time 0.7, corresponding to the fourth event (time-point is 0-origin) in the given log.</p>"},{"location":"getting_started/#timing-constraints","title":"Timing constraints","text":"<p>We can impose timing constraints on the monitored log. For example, one can detect all the arrivals of emails from <code>carol@example.net</code> after 1 time unit as follows.</p> <pre><code>within (&gt; 1) {\n    zero_or_more {\n        arrival(sender)\n    };\n    arrival(sender | sender == \"carol@example.net\" )\n}\n</code></pre> <p>An example of the usage and the result is as follows.</p> <pre><code>symon -nf ./carol-after-1.symon &lt; example.log\n</code></pre> <pre><code>@2.000000.  (time-point 10) true\n@2.900000.  (time-point 15) true\n</code></pre>"},{"location":"getting_started/#concrete-variables","title":"(Concrete) Variables","text":"<p>SyMon supports variables. For instance, one can count the number of message arrivals from <code>alice@example.com</code> and detect the 11th arrival as follows. We note that in SyMon, we use <code>==</code> for equality of strings while <code>=</code> for equality of numbers.</p> <pre><code>var {\n    count: number;\n}\n\ninit {\n    count = 0\n}\n\nsignature arrival {\n    sender: string;\n}\n\none_or_more {\n    one_of {\n        arrival( sender | sender != \"alice@example.com\" &amp;&amp; count &lt;= 10 )\n    } or {\n        arrival( sender | sender == \"alice@example.com\" &amp;&amp; count &lt; 10 | count := count + 1 )\n    }\n};\narrival( sender | sender == \"alice@example.com\" &amp;&amp; count = 10 | count := count + 1 )\n</code></pre> <p>An example of the usage and the result is as follows.</p> <pre><code>symon -pnf ./alice-11.symon &lt; example.log\n</code></pre> <pre><code>@3.1.   (time-point 16) Num: A = 11 Clock: true\n</code></pre>"},{"location":"getting_started/#parametric-variables","title":"Parametric Variables","text":"<p>SyMon also supports parametric variables, i.e., variables whose values are not explicitly specified, and symbolically handled based on constraints. For instance, one can detect the arrivals of more than 10 messages from the same sender within 3 time units as follows.</p> <pre><code>var {\n    current_sender: string;\n    count: number;\n}\n\nsignature arrival {\n    sender: string;\n}\n\none_or_more {\n    arrival(sender)\n};\n# Nondeterministically start counting for current_sender\narrival( sender | sender == current_sender | count := 1 );\nwithin (&lt;= 3) {\n    one_or_more {\n        one_of {\n            arrival( sender | sender != current_sender &amp;&amp; count &lt;= 10 )\n        } or {\n            arrival( sender | sender == current_sender &amp;&amp; count &lt; 10 | count := count + 1 )\n        }\n    };\n    arrival( sender | sender == current_sender &amp;&amp; count = 10 | count := count + 1 )\n}\n</code></pre> <p>An example of the usage and the result is as follows.</p> <pre><code>symon -dnf ./frequent.symon &lt; example.log\n</code></pre> <pre><code>@3.300000.  (time-point 18) x0 == alice@example.com A = 11\n</code></pre>"},{"location":"install/","title":"Installation","text":"<p>SyMon is fully implemented in C++. SyMon works on many UNIX-like operating systems. We tested SyMon on macOS Sequoia 15.6, Ubuntu 24.04, and Arch Linux.</p>"},{"location":"install/#installation-with-homebrew","title":"Installation with Homebrew","text":"<p>On macOS, it is the simplest to install SyMon using Homebrew.</p> <pre><code>brew install --HEAD maswag/scientific/symon\n</code></pre> <p>Then, you can just run symon, for example, as follows.</p> <pre><code>symon -pnf [foo.symon] &lt; [bar.log] \n</code></pre> <p>You can likely \"run\" the .symon file by appropriately specify the shebang.</p>"},{"location":"install/#installation-with-docker","title":"Installation with Docker","text":"<p>SyMon can be also used within a docker container.</p> <pre><code>docker pull maswag/symon:latest\n</code></pre> <p>Then, you can run symon. Notice that you have to specify <code>-v</code> option to bind the directory containing .symon file.</p> <pre><code>docker run -i -v $PWD:/tmp maswag/ symon:latest -pnf /tmp/[foo.symon] &lt; [bar.log]\n</code></pre>"},{"location":"install/#building-from-scratch","title":"Building from scratch","text":"<p>To build SyMon from scratch, you need to install the following dependencies.</p> <ul> <li>C++ compiler supporting C++17 and the corresponding libraries.</li> <li>Boost (&gt;= 1.67.0)</li> <li>CMake (&gt;= 3.25)</li> <li>Parma Polyhedra Library</li> <li>Tree Sitter</li> </ul> <p>On Ubuntu, the above can be installed as follows.</p> <pre><code>sudo apt-get install libppl-dev \\\n    libboost-all-dev \\\n    cmake \\\n    libgmp-dev \\\n    libtree-sitter-dev\n</code></pre> <p>First, you need to build and install the grammar definition of SyMon.</p> <pre><code>git clone https://github.com/maswag/tree-sitter-symon.git /tmp/tree-sitter-symon\ncmake -B /tmp/tree-sitter-symon/build -S /tmp/tree-sitter-symon\ncmake --build /tmp/tree-sitter-symon/build\nsudo cmake --install /tmp/tree-sitter-symon/build\n</code></pre> <p>Then, you can build and install SyMon.</p> <pre><code>git clone https://github.com/maswag/symon.git /tmp/symon\ncmake -DCMAKE_BUILD_TYPE=Release -B /tmp/symon/build -S /tmp/symon\ncmake --build /tmp/symon/build\nsudo cmake --install /tmp/symon/build\n</code></pre>"},{"location":"syntax/","title":"SyMon's specification language","text":"<p>In SyMon, a specification language based on timed regular expressions (TREs) [ACM02] can be used. The following shows some of the syntax of SyMon's specification language.</p> <pre><code>expr : atomic\n     | expr_variable\n     | expr &amp;&amp; expr\n     | all_of { expr } and { expr }\n     | expr || expr\n     | one_of { expr } and { expr }\n     | expr ; expr\n     | expr *\n     | zero_or_more { expr }\n     | expr +\n     | one_or_more { expr }\n     | expr ?\n     | optional { expr }\n     | expr % timing_constraint\n     | within timing_constraint { expr }\n     | ( expr )\n\natomic : identifier ( args | guard | updates )\n       | identifier ( args | guard )\n       | identifier ( args )\n\nguard : string_or_variable == string_or_variable\n      | string_or_variable != string_or_variable\n      | number_or_variable &gt; number_or_variable\n      | number_or_variable &gt;= number_or_variable\n      | number_or_variable &lt;&gt; number_or_variable\n      | number_or_variable &lt;= number_or_variable\n      | number_or_variable &lt; number_or_variable\n      | guard &amp;&amp; guard\n</code></pre>"},{"location":"syntax/#reference","title":"Reference","text":"<ul> <li>[ACM02] Timed regular expressions. Eugene Asarin, Paul Caspi, and Oded Maler, Journal of the ACM, Volume 49 Issue 2, March 2002, Pages 172-206</li> </ul>"},{"location":"tools/","title":"Related Tools","text":"<ul> <li>tree-sitter-symon: the grammar of SyMon's specification language in tree-sitter.</li> <li>symon-format: a source formatter for SyMon.</li> <li>symon-mode: a major mode for writing SyMon's specification.</li> </ul>"}]}