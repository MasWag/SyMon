#+TITLE: Relay Detection with SyMon
#+AUTHOR: Masaki Waga
#+EMAIL: mwaga@fos.kuis.kyoto-u.ac.jp
#+OPTIONS: toc:nil

This is an example to detect SMTP relay using [[https://github.com/MasWag/SyMon/][SyMon]]. See [[https://www.exim.org/exim-html-3.20/doc/html/spec_46.html#SEC813][this document]] for the detail of the relevant configuration of Exim4. This example consists of a Python script =convert_log.py= to clean up and construct a log file for SyMon and the files required by SyMon.

* What Counts as Relay

In the context of SMTP and Exim, a /relay/ occurs when the server accepts a message from an external sender (i.e., not part of our internal domain =example.com=) and then delivers that message to a destination address that is also outside =example.com=.

This means that:

- Mail from =alice@example.com= to =bob@example.com= is /not a relay/ (internal to internal).
- Mail from =alice@example.com= to =carol@gmail.com= is /not a relay/ (internal to external, normal outgoing mail).
- Mail from =dave@gmail.com= to =bob@example.com= is /not a relay/ (external to internal, normal incoming mail).
- Mail from =dave@gmail.com= to =carol@yahoo.com= is /relay/ (external to external).

By default, relaying should only be allowed for authenticated users or whitelisted hosts. If unauthenticated relays are detected, they may indicate a misconfiguration or abuse.

* Requirements

- [[https://github.com/MasWag/SyMon/][SyMon]]
- Python3
- Emacs
  - to tangle the resulting files from relay.org

* Usage

The usage of the generated files is as follows:

#+BEGIN_SRC sh
  sudo cat /var/log/exim4/mainlog |
      ./convert_log.py |
      ./relay.symon |
      ./pretty_print.sh
#+END_SRC

In the converted log, the timestamp is the duration since the beginning of the day in seconds.

You can re-generate =relay.symon= by ~make~. You can also generate the document with ~make doc~

* Events

We monitor the following events:

- =arrival=: The event showing the message arrival. This is shown as =<== in the raw log.
- =delivery=: The event showing the normal message delivery. This is shown as ==>= in the raw log
- =complete=: The event shows the end of a transaction. This is shown as =Completed= in the raw log

Each event is tied with a string =id= corresponding to the unique identifier of the message.

In addition, arrival event has the following fields:
- =sender=: The email address of the sender, e.g., =example@example.com=.
- =sender_domain=: The domain of the sender email address, e.g., =example.com=.
- =host=: The name of the source host, i.e., the =H= field.
- =auth=: The authentication information, i.e., the =A= field.
- =user=: The user of the event, i.e., the =U= field.

The corresponding signature for SyMon is as follows:

#+NAME: ARRIVAL_SIGNATURE
#+BEGIN_SRC symon
  signature arrival {
      id: string;
      sender: string;
      sender_domain: string;
      host: string;
      auth: string;
      user: string;
  }
#+END_SRC

In addition to =id=, delivery event has the following fields:
- =destination=: The email address of the destination.
- =destination_domain=: The domain of the destination email address.

The corresponding signature for SyMon is as follows (i.e. the event =arrival= is augmented with three string fields and zero numeric fields):

#+NAME: DELIVERY_SIGNATURE
#+BEGIN_SRC symon
  signature delivery {
      id: string;
      destination: string;
      destination_domain: string;
  }
#+END_SRC

Overall, we use the following signature to specify the monitored events.

#+NAME: SIGNATURES
#+BEGIN_SRC symon :noweb yes
  <<ARRIVAL_SIGNATURE>>
  <<DELIVERY_SIGNATURE>>
  signature complete {
      id: string;
  }
#+END_SRC

* Specification

What we want to do in the monitoring process is as follows:

- It waits for =arrival= of the (parameterized) current id.
  - If the sender's domain is =example.com=, it is good and we stop
  - Otherwise, we assign =sender=, =host=, and =user= to the internal variables for reporting.
- After the =arrival=, it waits for =delivery= or =complete= with the current id.
  - We stop tracking the id after these events.
  - If we detect a =delivery= whose the destination domain is not =example.com=, it is a relay and we raise an alert.
    - We also save =destination= for reporting.

Overall, we need the following (global) variables.

#+NAME: VARIABLES
#+BEGIN_SRC symon
  var {
      current_id: string;
      current_sender: string;
      current_host: string;
      current_user: string;
      current_auth: string;
      current_destination: string;
  }
#+END_SRC

First, we ignore events before tracking the current transaction.

#+NAME: IGNORE_BEFORE
#+BEGIN_SRC symon
  zero_or_more {
      one_of {
          arrival(id, sender, sender_domain, host, auth, user)
      } or {
          delivery(id, destination, destination_domain)
      } or {
          complete(id)
      }
  }
#+END_SRC

Then, we detect a relevant message arrival from non-internal domain (i.e., other than =example.com= or =none=).

#+NAME: ARRIVAL
#+BEGIN_SRC symon
  arrival(id, sender, sender_domain, host, auth, user | sender_domain != "example.com" && sender_domain != "none" | current_id := id; current_sender := sender; current_host := host; current_auth := auth; current_user := user)
#+END_SRC

After that, we ignore events with =id= not the =current_id=.

#+NAME: IGNORE_MIDDLE
#+BEGIN_SRC symon
  zero_or_more {
      one_of {
          arrival(id, sender, sender_domain, host, auth, user | id != current_id)
      } or {
          delivery(id, destination, destination_domain | id != current_id)
      } or {
          complete(id | id != current_id)
      }
  }
#+END_SRC

Finally, we deem that it is a relay if the destination is not our internal addresses (i.e., =example.com=).

#+NAME: DELIVERY
#+BEGIN_SRC symon
  delivery(id, destination, destination_domain | id == current_id && destination_domain != "example.com" | current_destination := destination)
#+END_SRC

Overall, the following shows the specification.

#+BEGIN_SRC symon :tangle relay.symon :noweb yes :shebang #!/usr/bin/env symon -nf
<<VARIABLES>>

<<SIGNATURES>>

<<IGNORE_BEFORE>>;
<<ARRIVAL>>;
<<IGNORE_MIDDLE>>;
<<DELIVERY>>
#+END_SRC

* Example Execution

Here is an example of the log generated by ~convert_log.py~.

#+BEGIN_SRC txt :tangle example.log
arrival	1rXYZa-0002BC-GH	alice@example.com	example.com	mail.example.com	PLAIN	alice	0.0
arrival	1rXYZa-0002BD-IJ	dave@gmail.com	gmail.com	mail-ot1-f45.google.com	none	none	0.1
arrival	1rXYZa-0002BE-KL	erin@example.com	example.com	mail.example.com	LOGIN	erin	0.2
delivery	1rXYZa-0002BC-GH	bob@example.com	example.com	0.3
delivery	1rXYZa-0002BD-IJ	carol@yahoo.com	yahoo.com	0.4
delivery	1rXYZa-0002BE-KL	frank@hotmail.com	hotmail.com	0.5
complete	1rXYZa-0002BC-GH	0.6
complete	1rXYZa-0002BD-IJ	0.7
complete	1rXYZa-0002BE-KL	0.8
#+END_SRC

Here is the command to run SyMon with a monitoring result:

#+BEGIN_SRC sh :results output replace :exports both
  cat example.log | 
      ./relay.symon |
      ./pretty_print.sh
#+END_SRC

#+RESULTS:
: @0.400000.	(time-point 4)	id: 1rXYZa-0002BD-IJ	sender: dave@gmail.com	host: mail-ot1-f45.google.com	user: none	auth: none	destination: carol@yahoo.com	
